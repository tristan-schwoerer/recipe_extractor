"""
Recipe extraction engine using Google's LangExtract.

This module handles the core extraction logic, converting unstructured
recipe text into structured Recipe objects.
"""
import logging
from typing import Optional
import langextract as lx
from langextract.data import ExampleData, Extraction

from src.models.recipe import Recipe, Ingredient

logger = logging.getLogger(__name__)


class RecipeExtractor:
    """Extracts structured recipe data from unstructured text using LangExtract."""
    
    def __init__(self, api_key: str, model: str = "gemini-2.5-pro"):
        """Initialize the recipe extractor.
        
        Args:
            api_key: API key for the language model
            model: The model to use for extraction
        """
        self.api_key = api_key
        self.model = model
        logger.info(f"Initialized RecipeExtractor with model: {model}")
    
    def _parse_ingredient_groups(self, text: str) -> dict:
        """Parse ingredient group structure from formatted text.
        
        This only works with specially formatted text (from site-specific scrapers)
        that has "Ingredients:" followed by group headers with colons and indented
        ingredient lines starting with "  -".
        
        Args:
            text: Formatted recipe text with group headers
            
        Returns:
            Dict mapping ingredient names to their group names, or empty dict if no structured format detected
        """
        # Only parse groups if we have the specific structured format from our scrapers
        # Look for "Ingredients:" followed by indented ingredient lines
        if '\nIngredients:\n' not in text:
            return {}
        
        ingredient_to_group = {}
        current_group = None
        in_ingredients_section = False
        
        for line in text.split('\n'):
            line_stripped = line.strip()
            
            # Check if we're entering ingredients section (exact match from our scrapers)
            if line_stripped == 'Ingredients:':
                in_ingredients_section = True
                continue
            
            # Check if we're leaving ingredients section
            if in_ingredients_section and line_stripped.lower().startswith('instructions'):
                break
            
            if not in_ingredients_section:
                continue
            
            # Check for group header (line ending with : and not indented/starting with -)
            if line_stripped and line_stripped.endswith(':') and not line.startswith('  ') and not line_stripped.startswith('-'):
                current_group = line_stripped.rstrip(':')
                continue
            
            # Parse ingredient line (indented with "  -" from our scraper format)
            if line.startswith('  -'):
                # Extract ingredient name (text after quantity/unit)
                ingredient_line = line_stripped.lstrip('- ').strip()
                # Try to extract just the ingredient name (after quantity and unit)
                parts = ingredient_line.split()
                if len(parts) >= 2:
                    # Rough heuristic: ingredient name is everything after the first 1-2 tokens
                    # This assumes format like "600g Mehl" or "1TL Zucker"
                    ingredient_name = ' '.join(parts[1:]) if len(parts) > 1 else parts[0]
                    if current_group and ingredient_name:
                        ingredient_to_group[ingredient_name.lower()] = current_group
        
        return ingredient_to_group
    
    def extract_recipe(self, text: str) -> Optional[Recipe]:
        """Extract recipe information from text.
        
        Args:
            text: The raw recipe text
            
        Returns:
            A Recipe object with extracted information, or None if extraction fails
        """
        logger.info(f"Extracting recipe from text (length: {len(text)} chars)")
        
        if len(text.strip()) < 100:
            logger.warning("Text too short for meaningful recipe extraction")
            return None
        
        # Parse groups from text structure
        ingredient_groups = self._parse_ingredient_groups(text)
        
        try:
            # Define the prompt for extraction
            prompt_description = """
Extract recipe information from the provided text in any language (English, German, Danish, etc.). 

Identify and extract:
1. The recipe title
2. ALL ingredients with their quantities and units

For each ingredient, break it down into:
- name: the ingredient name INCLUDING any preparation notes or annotations (e.g., "Salz, gehäuft", "Peperoni, eingelegte", "Wasser, lauwarmes", "butter, softened", "Salz und Pfeffer")
- quantity: the numeric amount (e.g., 2.5, 250, 0.5), or null if not specified
- unit: ONLY the base measurement unit WITHOUT annotations (e.g., "g", "ml", "TL", "EL", "Pck.", "cups", "tsp"), or null if not specified
  Do NOT include preparation notes in the unit field (e.g., use "TL" not "TL, gehäuft")
- group: optional group/section name if ingredients are organized into clear subsections (e.g., "For the dough", "Für den Boden"). Use null if not applicable.

CRITICAL RULES:
- DO NOT TRANSLATE INGREDIENTS - Keep ingredient names in their ORIGINAL LANGUAGE as written in the recipe
- If the recipe is in Danish, keep ingredient names in Danish (e.g., "krustader", "ørredrogn", "rejer")
- If the recipe is in German, keep ingredient names in German (e.g., "Mehl", "Zucker", "Eier")
- Annotations like "gehäuft" (heaped), "eingelegt" (pickled), "gerieben" (grated), "lauwarm" (lukewarm) should be part of the ingredient NAME, not the unit
- The unit field should contain ONLY standard measurement units  
- Extract EVERY ingredient from the ingredient list, even if they don't have a quantity or unit
- For ingredients without quantity/unit, set both to null
- Keep the full specific ingredient name as written in the recipe
- Extract each ingredient ONLY ONCE - do not create duplicate entries or translated versions
- IMPORTANT: If an ingredient line contains BOTH metric and imperial measurements (e.g., "1.75kg/ 3.5lb" or "20g/ 1 tbsp"), extract ONLY the FIRST measurement listed (metric). Do NOT create separate entries for each unit system.

Return the extracted information in the following JSON structure:
{
  "extractions": [
    {
      "extraction_class": "Recipe",
      "extraction_text": "{
        \\"title\\": \\"Recipe Title\\",
        \\"ingredients\\": [
          {
            \\"name\\": \\"ingredient name\\",
            \\"quantity\\": 2.0,
            \\"unit\\": \\"cups\\",
            \\"group\\": \\"For the dough\\"
          }
        ]
      }"
    }
  ]
}
"""
            
            # Create example data to guide the extraction
            examples = [
                ExampleData(
                    text="""
Chocolate Chip Cookies

Ingredients:
- 2 1/4 cups all-purpose flour
- 1 tsp baking soda
- 1 tsp salt
- 1 cup butter, softened
- 3/4 cup granulated sugar
- 2 large eggs
- 2 cups chocolate chips
- Powdered Sugar
- Baking paper
""",
                    extractions=[
                        Extraction(
                            extraction_class="Recipe",
                            extraction_text="""{
  "title": "Chocolate Chip Cookies",
  "ingredients": [
    {"name": "all-purpose flour", "quantity": 2.25, "unit": "cups", "group": null},
    {"name": "baking soda", "quantity": 1.0, "unit": "tsp", "group": null},
    {"name": "salt", "quantity": 1.0, "unit": "tsp", "group": null},
    {"name": "butter, softened", "quantity": 1.0, "unit": "cup", "group": null},
    {"name": "granulated sugar", "quantity": 0.75, "unit": "cup", "group": null},
    {"name": "eggs", "quantity": 2.0, "unit": "large", "group": null},
    {"name": "chocolate chips", "quantity": 2.0, "unit": "cups", "group": null},
    {"name": "Powdered Sugar", "quantity": null, "unit": null, "group": null},
    {"name": "Baking paper", "quantity": null, "unit": null, "group": null}
  ]
}"""
                        )
                    ]
                ),
                ExampleData(
                    text="""
Gewürzkuchen

Zutaten:
- 4 Ei(er)
- 300 g Zucker
- 350 g Mehl
- 1 Pck. Backpulver
- 250 ml Olivenöl
- 1 TL, gehäuft Salz
- 2 Paprikaschote(n), rote
- Petersilie
- Salz und Pfeffer
- Oregano
""",
                    extractions=[
                        Extraction(
                            extraction_class="Recipe",
                            extraction_text="""{
  "title": "Gewürzkuchen",
  "ingredients": [
    {"name": "Ei(er)", "quantity": 4.0, "unit": null, "group": null},
    {"name": "Zucker", "quantity": 300.0, "unit": "g", "group": null},
    {"name": "Mehl", "quantity": 350.0, "unit": "g", "group": null},
    {"name": "Backpulver", "quantity": 1.0, "unit": "Pck.", "group": null},
    {"name": "Olivenöl", "quantity": 250.0, "unit": "ml", "group": null},
    {"name": "Salz, gehäuft", "quantity": 1.0, "unit": "TL", "group": null},
    {"name": "Paprikaschote(n), rote", "quantity": 2.0, "unit": null, "group": null},
    {"name": "Petersilie", "quantity": null, "unit": null, "group": null},
    {"name": "Salz und Pfeffer", "quantity": null, "unit": null, "group": null},
    {"name": "Oregano", "quantity": null, "unit": null, "group": null}
  ]
}"""
                        )
                    ]
                ),
                ExampleData(
                    text="""
Recipe: Pizza Dough

Ingredients:

For the dough:
  - 500g Flour
  - 300ml Water, lukewarm
  - 1TL Salt
  - 7g Yeast

For the topping:
  - 200g Tomato sauce
  - 300g Mozzarella
  - Basil
  - Olive oil
""",
                    extractions=[
                        Extraction(
                            extraction_class="Recipe",
                            extraction_text="""{
  "title": "Pizza Dough",
  "ingredients": [
    {"name": "Flour", "quantity": 500.0, "unit": "g", "group": "For the dough"},
    {"name": "Water, lukewarm", "quantity": 300.0, "unit": "ml", "group": "For the dough"},
    {"name": "Salt", "quantity": 1.0, "unit": "TL", "group": "For the dough"},
    {"name": "Yeast", "quantity": 7.0, "unit": "g", "group": "For the dough"},
    {"name": "Tomato sauce", "quantity": 200.0, "unit": "g", "group": "For the topping"},
    {"name": "Mozzarella", "quantity": 300.0, "unit": "g", "group": "For the topping"},
    {"name": "Basil", "quantity": null, "unit": null, "group": "For the topping"},
    {"name": "Olive oil", "quantity": null, "unit": null, "group": "For the topping"}
  ]
}"""
                        )
                    ]
                ),
                ExampleData(
                    text="""
Recipe: Beef Stew

Ingredients:
- 1.5kg/ 3.3lb beef chuck, cubed
- 500ml/ 2 cups beef broth
- 3 tbsp/ 45g butter
- 2 large onions
- Salt and pepper

For serving:
- Fresh parsley
""",
                    extractions=[
                        Extraction(
                            extraction_class="Recipe",
                            extraction_text="""{
  "title": "Beef Stew",
  "ingredients": [
    {"name": "beef chuck, cubed", "quantity": 1.5, "unit": "kg", "group": null},
    {"name": "beef broth", "quantity": 500.0, "unit": "ml", "group": null},
    {"name": "butter", "quantity": 3.0, "unit": "tbsp", "group": null},
    {"name": "onions", "quantity": 2.0, "unit": "large", "group": null},
    {"name": "Salt and pepper", "quantity": null, "unit": null, "group": null},
    {"name": "Fresh parsley", "quantity": null, "unit": null, "group": "For serving"}
  ]
}"""
                        )
                    ]
                )
            ]
            
            # Perform extraction
            result = lx.extract(
                text_or_documents=text,
                prompt_description=prompt_description,
                model_id=self.model,
                examples=examples,
                api_key=self.api_key
            )
            
            # Parse the results
            if result and hasattr(result, 'extractions') and result.extractions:
                main_recipe = None
                max_ingredients = 0
                all_recipes = []
                
                for extraction in result.extractions:
                    if extraction.extraction_class == "Recipe":
                        try:
                            # Parse the JSON string into a Recipe object
                            import json
                            import re
                            
                            extraction_text = extraction.extraction_text
                            
                            # Try to fix common JSON errors from AI
                            try:
                                recipe_data = json.loads(extraction_text)
                            except json.JSONDecodeError as e:
                                logger.warning(f"JSON parse error, attempting to fix: {e}")
                                fixed_text = extraction_text
                                
                                # Strategy 1: Try to find and fix incomplete last object in array
                                # Look for pattern: "key": value\n  ]\n}
                                # Should be: "key": value}\n  ]\n}
                                fixed_text = re.sub(
                                    r'("(?:quantity|unit|name)":\s*(?:null|"[^"]*"|\d+(?:\.\d+)?))\s*\n\s*\]',
                                    r'\1}\n  ]',
                                    fixed_text
                                )
                                
                                try:
                                    recipe_data = json.loads(fixed_text)
                                    logger.info("Successfully repaired malformed JSON (incomplete object)")
                                except json.JSONDecodeError:
                                    # Strategy 2: Count and add missing braces/brackets at the end
                                    open_brackets = fixed_text.count('[')
                                    close_brackets = fixed_text.count(']')
                                    open_braces = fixed_text.count('{')
                                    close_braces = fixed_text.count('}')
                                    
                                    # Add missing closures
                                    if close_braces < open_braces:
                                        fixed_text += '}' * (open_braces - close_braces)
                                    if close_brackets < open_brackets:
                                        fixed_text += ']' * (open_brackets - close_brackets)
                                    
                                    try:
                                        recipe_data = json.loads(fixed_text)
                                        logger.info("Successfully repaired malformed JSON (missing closures)")
                                    except:
                                        logger.error("Could not repair JSON, skipping this extraction")
                                        raise
                            
                            # Skip partial extractions (e.g., from later chunks)
                            if not recipe_data.get('title'):
                                logger.debug("Skipping partial extraction without title")
                                continue
                            
                            # Skip extractions where the title is actually an ingredient name or invalid
                            title = recipe_data.get('title', '')
                            title_lower = title.lower()

                            
                            # Convert ingredient dictionaries to Ingredient objects
                            ingredients = []
                            for ing in recipe_data.get('ingredients', []):
                                name = ing.get('name', '')
                                quantity = ing.get('quantity')
                                unit = ing.get('unit')
                                group = ing.get('group')
                                
                                # Post-process: if unit contains annotations (comma-separated), 
                                # move the annotation to the ingredient name
                                if unit and ',' in unit:
                                    parts = unit.split(',', 1)
                                    base_unit = parts[0].strip()
                                    annotation = parts[1].strip()
                                    
                                    # Move annotation to name if not already there
                                    if annotation and annotation.lower() not in name.lower():
                                        name = f"{name}, {annotation}"
                                    unit = base_unit
                                
                                # Clean up unit parentheses (e.g., "Prise(n)" -> "Prise")
                                if unit:
                                    unit = unit.replace('(n)', '').replace('(', '').replace(')', '')
                                
                                # If group not extracted by LLM, try to find it from parsed structure
                                if not group and ingredient_groups:
                                    # Try to match ingredient name to our parsed groups
                                    name_lower = name.lower()
                                    for parsed_name, parsed_group in ingredient_groups.items():
                                        if parsed_name in name_lower or name_lower.startswith(parsed_name.split(',')[0].strip()):
                                            group = parsed_group
                                            break
                                
                                # Handle ingredients with missing quantity or unit
                                ingredient = Ingredient(
                                    name=name,
                                    quantity=quantity,
                                    unit=unit,
                                    group=group
                                )
                                ingredients.append(ingredient)
                            
                            # Create the Recipe object
                            recipe = Recipe(
                                title=recipe_data.get('title', ''),
                                ingredients=ingredients
                            )
                            
                            logger.info(f"Found recipe: {recipe.title}")
                            logger.info(f"  - {len(recipe.ingredients)} ingredients")
                            
                            # Skip recipes with no ingredients or likely junk titles
                            if len(recipe.ingredients) == 0 or len(recipe.title) > 100:
                                continue
                            
                            all_recipes.append(recipe)
                            
                            # Track the recipe with the most ingredients as the main one
                            if len(recipe.ingredients) > max_ingredients:
                                main_recipe = recipe
                                max_ingredients = len(recipe.ingredients)
                            
                        except Exception as e:
                            logger.error(f"Error parsing recipe extraction: {e}")
                            logger.error(f"Extraction text: {extraction.extraction_text}")
                
                # Multiple extractions found - use the one with the most ingredients
                if main_recipe and len(all_recipes) > 1:
                    logger.info(f"Multiple extractions found: {len(all_recipes)} recipe extractions")
                    logger.info(f"Main recipe (selected): '{main_recipe.title}' with {len(main_recipe.ingredients)} ingredients")
                    
                    for recipe in all_recipes:
                        if recipe != main_recipe:
                            logger.info(f"  Ignored secondary extraction: '{recipe.title}' has {len(recipe.ingredients)} ingredients:")
                            for ing in recipe.ingredients:
                                logger.info(f"    - {ing.name} (qty: {ing.quantity}, unit: {ing.unit}, group: {ing.group})")
                    
                    logger.info(f"Using main extraction only (no merging) to avoid hallucinated ingredients")
                elif main_recipe:
                    logger.info(f"Selected recipe: {main_recipe.title} with {len(main_recipe.ingredients)} ingredients")
                
                return main_recipe
            
            logger.warning("No recipe extractions found in the result")
            return None
            
        except Exception as e:
            logger.error(f"Error during recipe extraction: {str(e)}", exc_info=True)
            return None

REMOVE_AFTER_THIS = """
                            if any(pattern in title_lower for pattern in ingredient_title_patterns):
                                # Add the title itself as an ingredient
                                title_ingredient = Ingredient(
                                    name=recipe.title,
                                    quantity=None,
                                    unit=None
                                )
                                # Check if not already present
                                if not any(ing.name.lower() == title_lower for ing in merged_ingredients):
                                    merged_ingredients.append(title_ingredient)
                                    logger.info(f"  + Added ingredient from extraction title: {recipe.title}")
                            
                            # Add ingredients that aren't already in the main recipe
                            for ing in recipe.ingredients:
                                logger.debug(f"    Checking: {ing.name}")
                                # If quantity/unit are missing, try to extract from the original text
                                # Common pattern: "2 Pkt.Puderzuckerfür den Guss" where quantity precedes ingredient name
                                if ing.quantity is None and ing.unit is None:
                                    import re
                                    # Search for the ingredient name in the original text with quantity before it
                                    # Pattern: number + optional space + unit + optional space + ingredient name
                                    ing_name_escaped = re.escape(ing.name)
                                    qty_pattern = r'(\d+(?:\.\d+)?)\s*(Pkt\.|g|kg|ml|l|Liter|EL|TL|Msp\.|Pck\.|Fläschchen)\.?\s*' + ing_name_escaped
                                    match = re.search(qty_pattern, text, re.IGNORECASE)
                                    if match:
                                        try:
                                            ing.quantity = float(match.group(1))
                                            ing.unit = match.group(2)
                                            logger.debug(f"Recovered quantity/unit for {ing.name}: {ing.quantity} {ing.unit}")
                                        except (ValueError, AttributeError):
                                            pass
                                
                                # Check if this ingredient is already in the list (fuzzy matching)
                                ing_name_lower = ing.name.lower()
                                is_duplicate = False
                                
                                for existing in merged_ingredients:
                                    existing_name_lower = existing.name.lower()
                                    
                                    # Exact match
                                    if ing_name_lower == existing_name_lower:
                                        is_duplicate = True
                                        break
                                    
                                    # Check if one is substring of the other (e.g., "Wasser" in "Wasser, lauwarmes")
                                    # But be careful: "Zucker" in "Puderzucker" doesn't mean they're the same!
                                    # Check both prefix and suffix matches (e.g., "Öl" in "Olivenöl", "Hefe" in "Frischhefe")
                                    shorter = min(len(ing_name_lower), len(existing_name_lower))
                                    if shorter > 3:  # Only for names longer than 3 chars
                                        # Check if one name starts OR ends with the other
                                        longer_name = existing_name_lower if len(existing_name_lower) > len(ing_name_lower) else ing_name_lower
                                        shorter_name = ing_name_lower if len(ing_name_lower) < len(existing_name_lower) else existing_name_lower
                                        
                                        # Check prefix match (e.g., "wasser" and "wasser, lauwarmes")
                                        if longer_name.startswith(shorter_name):
                                            # Require at least 60% similarity to avoid false positives
                                            if shorter / len(longer_name) > 0.6:
                                                is_duplicate = True
                                                logger.debug(f"    → Prefix duplicate: '{ing.name}' ≈ '{existing.name}'")
                                                break
                                        
                                        # Check suffix match (e.g., "öl" in "olivenöl", "hefe" in "frischhefe")
                                        if longer_name.endswith(shorter_name) and shorter > 3:
                                            # For suffix matches, be more strict (require longer base name)
                                            # to avoid matching "er" in "butter", etc.
                                            if shorter / len(longer_name) > 0.5:
                                                is_duplicate = True
                                                logger.debug(f"    → Suffix duplicate: '{ing.name}' ≈ '{existing.name}'")
                                                break
                                    
                                    # Also check for common base word (e.g., "zwiebel" in both "zwiebel(n)" and "zwiebeln")
                                    # Remove punctuation, split on spaces and commas, check for word overlap
                                    import re
                                    clean_ing = re.sub(r'[^\w\s]', '', ing_name_lower)
                                    clean_existing = re.sub(r'[^\w\s]', '', existing_name_lower)
                                    ing_words = set(clean_ing.split())
                                    existing_words = set(clean_existing.split())
                                    
                                    # Check for exact word matches
                                    common_words = ing_words & existing_words
                                    if common_words:
                                        longest_common = max(len(w) for w in common_words)
                                        if longest_common > 5:
                                            is_duplicate = True
                                            logger.debug(f"    → Word match duplicate: '{ing.name}' ≈ '{existing.name}'")
                                            break
                                    
                                    # Check if any word from one is substring of word in other (e.g., "paprika" in "paprikaschoten")
                                    for w1 in ing_words:
                                        for w2 in existing_words:
                                            if len(w1) > 5 and len(w2) > 5:
                                                if w1 in w2 or w2 in w1:
                                                    is_duplicate = True
                                                    logger.debug(f"    → Word overlap duplicate: '{ing.name}' ≈ '{existing.name}' ('{w1}' ≈ '{w2}')")
                                                    break
                                        if is_duplicate:
                                            break
                                    
                                    # Additional check: if the shorter name appears as complete substring in longer name
                                    # This catches: "Hefe" in "Frischhefe", "Öl" in "Olivenöl", "Salz" in "Salz, gehäuft"
                                    if not is_duplicate:
                                        # Get the shorter and longer names
                                        if len(ing_name_lower) < len(existing_name_lower):
                                            short = ing_name_lower.strip()
                                            long = existing_name_lower.strip()
                                        else:
                                            short = existing_name_lower.strip()
                                            long = ing_name_lower.strip()
                                        
                                        # If short name is a complete word in the long name
                                        # Check as separate word (with word boundaries) or as compound part
                                        if len(short) > 3:  # Only for names longer than 3 chars
                                            # Check if short is the base of a compound word (e.g., "öl" in "olivenöl")
                                            if long.endswith(short):
                                                # Make sure it's a significant portion
                                                if len(short) / len(long) > 0.4:
                                                    is_duplicate = True
                                                    logger.debug(f"    → Compound base duplicate: '{ing.name}' ≈ '{existing.name}'")
                                            # Check if short appears as standalone word (e.g., "salz" in "salz, gehäuft")
                                            elif short in long.split() or f"{short}," in long or f", {short}" in long:
                                                is_duplicate = True
                                                logger.debug(f"    → Base word duplicate: '{ing.name}' ≈ '{existing.name}'")
                                if not is_duplicate:
                                    # Additional check: skip generic ingredients (no qty/unit) if a more specific version exists
                                    # This prevents adding "Hefe" when "Frischhefe" exists, or "Öl" when "Olivenöl" exists
                                    if ing.quantity is None and ing.unit is None:
                                        # Check if any existing ingredient contains this as a substring
                                        skip_generic = False
                                        for existing in merged_ingredients:
                                            if existing.quantity is not None or existing.unit is not None:
                                                # Check if the generic name is part of a more specific name
                                                if len(ing.name) > 3 and ing.name.lower() in existing.name.lower():
                                                    skip_generic = True
                                                    logger.debug(f"    → Skipping generic ingredient '{ing.name}' (more specific version '{existing.name}' exists)")
                                                    break
                                        if skip_generic:
                                            continue
                                        
                                        # Additional check: skip likely composite dish names or references
                                        # These are ingredients with no qty/unit that appear to be dish names rather than raw ingredients
                                        # ONLY apply this filter if the ingredient name is suspiciously long or matches specific patterns
                                        ing_name_lower = ing.name.lower()
                                        main_title_lower = main_recipe.title.lower()
                                        
                                        # Skip if it looks like a composite dish name (contains compound food words)
                                        # Patterns: word + "salat", word + "suppe", "skaller" (shells), etc.
                                        # BUT exclude simple ingredients like "salat" alone or common words
                                        import re
                                        composite_dish_patterns = [
                                            r'\w{4,}salat$',  # e.g., rejesalat, kartoffelsalat (at least 4 chars before "salat")
                                            r'\w{4,}suppe$',  # e.g., grøntsagssuppe, tomatsuppe
                                            r'\w{4,}skaller$',  # e.g., krustadeskaller (shells)
                                            r'\w+ret$',  # e.g., forret (appetizer)
                                            r'\w{4,}blanding$',  # e.g., krydderblanding (spice mix)
                                        ]
                                        
                                        is_composite_dish = any(re.match(pattern, ing_name_lower) for pattern in composite_dish_patterns)
                                        
                                        if is_composite_dish:
                                            # Extra validation: check if this overlaps with recipe title
                                            # This catches cases like "rejesalat", "skaldyrssalat" when title is "Krustader med rejesalat"
                                            title_words = set(main_title_lower.split())
                                            ing_words = set(ing_name_lower.split())
                                            significant_overlap = ing_words & title_words
                                            
                                            # Filter out common connecting words
                                            connecting_words = {'med', 'og', 'i', 'til', 'af', 'with', 'and', 'in', 'to', 'of', 'the', 'a', 'an', 'på'}
                                            significant_overlap = {w for w in significant_overlap if w not in connecting_words and len(w) > 3}
                                            
                                            if significant_overlap:
                                                logger.debug(f"    → Skipping likely dish reference '{ing.name}' (composite dish pattern + overlaps with recipe title: {significant_overlap})")
                                                continue
                                            
                                            # Also skip if the entire ingredient name is essentially a compound of main recipe words
                                            # e.g., "rejesalat" = "rejer" + "salat", both of which might be in the ingredient list
                                            logger.debug(f"    → Skipping likely composite dish name '{ing.name}'")
                                            continue
                                    
                                    merged_ingredients.append(ing)
                                    logger.info(f"  + Added ingredient from secondary extraction: {ing.name} (qty: {ing.quantity}, unit: {ing.unit})")
                    
                    main_recipe.ingredients = merged_ingredients
                    logger.info(f"Final recipe: {main_recipe.title} with {len(main_recipe.ingredients)} ingredients")
                    return main_recipe
                elif main_recipe:
                    logger.info(f"Selected recipe: {main_recipe.title} with {len(main_recipe.ingredients)} ingredients")
                    return main_recipe
            
            logger.warning("No recipe extractions found in the result")
            return None
            
        except Exception as e:
            logger.error(f"Error during recipe extraction: {str(e)}", exc_info=True)
            return None
